package cn.aezo.utils.io;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.NoSuchElementException;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.TimeUnit;

import org.apache.commons.net.ftp.FTPClient;
import org.apache.commons.net.ftp.FTPFile;
import org.apache.commons.net.ftp.FTPReply;
import org.apache.commons.pool.ObjectPool;
import org.apache.commons.pool.PoolableObjectFactory;

public class FtpU {
	private static FTPClient ftpClient;
	private static FTPClientPool pool;

	public static FTPClient getFtpClient() {
		return ftpClient;
	}

	public static void setFtpClient(FTPClient ftpClient) {
		FtpU.ftpClient = ftpClient;
	}
	
	public static FTPClientPool getPool() {
		return pool;
	}

	public static void setPool(FTPClientPool pool) {
		FtpU.pool = pool;
	}

	/**
	 * ftp上传文件（无法创建目录）
	 * @param file
	 * @throws Exception
	 */
	public static boolean upload(File localFile, String romotUpLoadePath) {    
        BufferedInputStream bis = null;    
        boolean success = false;    
        try {  
            boolean flag = ftpClient.changeWorkingDirectory(romotUpLoadePath); // 改变工作路径    
            System.out.println(flag);
            bis = new BufferedInputStream(new FileInputStream(localFile));    
            success = ftpClient.storeFile(localFile.getName(), bis);    
            if (success == true) {  
                return success;    
            }    
        } catch (FileNotFoundException e) {    
            e.printStackTrace();    
        } catch (IOException e) {    
            e.printStackTrace();    
        } finally {    
            if (bis != null) {    
                try {    
                    bis.close();    
                } catch (IOException e) {    
                    e.printStackTrace();    
                }    
            }    
        }    
        return success;    
    }   
	
	public static void upload(File file) throws Exception {
		if (file.isDirectory()) {
			ftpClient.makeDirectory(file.getName());
			ftpClient.changeWorkingDirectory(file.getName());
			String[] files = file.list();
			for (String str : files) {
				File file1 = new File(file.getPath() + "/" + str);
				if (file1.isDirectory()) {
					upload(file1);
					ftpClient.changeToParentDirectory();
				} else {
					File file2 = new File(file.getPath() + "/" + str);
					FileInputStream input = new FileInputStream(file2);
					ftpClient.storeFile(file2.getName(), input);
					input.close();
				}
			}
		} else {
			File file2 = new File(file.getPath());
			FileInputStream input = new FileInputStream(file2);
			ftpClient.storeFile(file2.getName(), input);
			input.close();
		}
	}
	
	@Deprecated
	public static void upload(String fileName, InputStream inputStream) throws Exception {
		ftpClient.storeFile(fileName, inputStream);
		inputStream.close();
	}

	/**
	 * 下载链接配置
	 * @param ftpInfo
	 * @param localBaseDir 本地目录
	 * @param remoteBaseDir 远程目录(或者文件名)
	 * @throws Exception
	 */
	public static void download(String localBaseDir, String remoteBaseDir) throws Exception {
		FTPFile[] files = null;
		boolean changedir = ftpClient.changeWorkingDirectory(remoteBaseDir);
		if (changedir) {
			ftpClient.setControlEncoding("UTF-8");
			files = ftpClient.listFiles();
			for (int i = 0; i < files.length; i++) {
				try {
					downloadFile(files[i], localBaseDir, remoteBaseDir);
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		}
	}
	
	/**
	 * 下载文件
	 * @param outputStream
	 * @param remoteBaseDir
	 * @throws IOException
	 * @author smalle
	 * @date 2016年12月26日 下午5:01:51
	 */
	public static void download(OutputStream outputStream, String remoteBaseDir) throws IOException {
		FTPFile[] files = null;
		boolean changedir = ftpClient.changeWorkingDirectory(remoteBaseDir);
		if (changedir) {
			ftpClient.setControlEncoding("UTF-8");
			files = ftpClient.listFiles(); // files = ftpClient.listFiles(remoteDir);
			for (int i = 0; i < files.length; i++) {
				try {
					ftpClient.retrieveFile(files[i].getName(), outputStream);
					outputStream.flush();
					outputStream.close();
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		}
	}

	/**
	 * 下载FTP文件 当你需要下载FTP文件的时候，调用此方法 根据<b>获取的文件名，本地地址，远程地址</b>进行下载
	 * @param ftpFile
	 * @param relativeLocalPath
	 * @param relativeRemotePath
	 */
	private static void downloadFile(FTPFile ftpFile, String relativeLocalPath, String relativeRemotePath) {
		if (ftpFile.isFile()) {
			if (ftpFile.getName().indexOf("?") == -1) {
				OutputStream outputStream = null;
				try {
					File locaFile = new File(relativeLocalPath + ftpFile.getName());
					// 判断文件是否存在，存在则返回
					if (locaFile.exists()) {
						return;
					} else {
						outputStream = new FileOutputStream(relativeLocalPath + ftpFile.getName());
				        ftpClient = pool.borrowObject(); // 如果不获取一个新的client，会出现下载的文件为0kb
						ftpClient.retrieveFile(ftpFile.getName(), outputStream);
						outputStream.flush();
						outputStream.close();
						
						// pool.returnObject(ftpClient);
					}
				} catch (Exception e) {
					e.printStackTrace();
				} finally {
					try {
						if (outputStream != null) {
							outputStream.close();
						}
					} catch (IOException e) {
						e.printStackTrace();
					}
				}
			}
		} else {
			String newlocalRelatePath = relativeLocalPath + ftpFile.getName();
			String newRemote = new String(relativeRemotePath + ftpFile.getName().toString());
			File fl = new File(newlocalRelatePath);
			if (!fl.exists()) {
				fl.mkdirs();
			}
			try {
				newlocalRelatePath = newlocalRelatePath + '/';
				newRemote = newRemote + "/";
				String currentWorkDir = ftpFile.getName().toString();
				boolean changedir = ftpClient.changeWorkingDirectory(currentWorkDir);
				if (changedir) {
					FTPFile[] files = null;
					files = ftpClient.listFiles();
					for (int i = 0; i < files.length; i++) {
						downloadFile(files[i], newlocalRelatePath, newRemote);
					}
				}
				if (changedir) {
					ftpClient.changeToParentDirectory();
				}
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
	}
	
	/**
	 * 实现了一个FTPClient连接池
	 */
	public static class FTPClientPool implements ObjectPool {
		private static final int DEFAULT_POOL_SIZE = 100; // TODO 10
		private final BlockingQueue<FTPClient> pool;
		private final FtpClientFactory factory;

		/**
		 * 初始化连接池，需要注入一个工厂来提供FTPClient实例
		 * 
		 * @param factory
		 * @throws Exception
		 */
		public FTPClientPool(FtpClientFactory factory) throws Exception {
			this(DEFAULT_POOL_SIZE, factory);
		}

		/**
		 *
		 * @param maxPoolSize
		 * @param factory
		 * @throws Exception
		 */
		public FTPClientPool(int poolSize, FtpClientFactory factory)
				throws Exception {
			this.factory = factory;
			pool = new ArrayBlockingQueue<FTPClient>(poolSize * 2);
			initPool(poolSize);
		}

		/**
		 * 初始化连接池，需要注入一个工厂来提供FTPClient实例
		 * 
		 * @param maxPoolSize
		 * @throws Exception
		 */
		private void initPool(int maxPoolSize) throws Exception {
			for (int i = 0; i < maxPoolSize; i++) {
				// 往池中添加对象
				addObject();
			}

		}

		/*
		 * (non-Javadoc)
		 * 
		 * @see org.apache.commons.pool.ObjectPool#borrowObject()
		 */
		public FTPClient borrowObject() throws Exception,
				NoSuchElementException, IllegalStateException {
			FTPClient client = pool.take();
			if (client == null) {
				client = factory.makeObject();
				addObject();
			} else if (!factory.validateObject(client)) {// 验证不通过
				// 使对象在池中失效
				invalidateObject(client);
				// 制造并添加新对象到池中
				client = factory.makeObject();
				addObject();
			}
			return client;

		}

		/*
		 * (non-Javadoc)
		 * 
		 * @see
		 * org.apache.commons.pool.ObjectPool#returnObject(java.lang.Object)
		 */
		public void returnObject(FTPClient client) throws Exception {
			if ((client != null) && !pool.offer(client, 3, TimeUnit.SECONDS)) {
				try {
					factory.destroyObject(client);
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
		}

		public void invalidateObject(FTPClient client) throws Exception {
			// 移除无效的客户端
			pool.remove(client);
		}

		/*
		 * (non-Javadoc)
		 * 
		 * @see org.apache.commons.pool.ObjectPool#addObject()
		 */
		public void addObject() throws Exception, IllegalStateException, UnsupportedOperationException {
			// 插入对象到队列
			pool.offer(factory.makeObject(), 3, TimeUnit.SECONDS);
		}

		public int getNumIdle() throws UnsupportedOperationException {
			return 0;
		}

		public int getNumActive() throws UnsupportedOperationException {
			return 0;
		}

		public void clear() throws Exception, UnsupportedOperationException {

		}

		/*
		 * (non-Javadoc)
		 * 
		 * @see org.apache.commons.pool.ObjectPool#close()
		 */
		public void close() throws Exception {
			while (pool.iterator().hasNext()) {
				FTPClient client = pool.take();
				factory.destroyObject(client);
			}
		}

		public void setFactory(PoolableObjectFactory factory)
				throws IllegalStateException, UnsupportedOperationException {

		}

		@Override
		public void returnObject(Object obj) throws Exception {
		}

		@Override
		public void invalidateObject(Object obj) throws Exception {
		}
	}

	/**
	 * FTPClient工厂类，通过FTPClient工厂提供FTPClient实例的创建和销毁
	 */
	public static class FtpClientFactory implements PoolableObjectFactory {
		private FTPClientConfigure config;

		// 给工厂传入一个参数对象，方便配置FTPClient的相关参数
		public FtpClientFactory(FTPClientConfigure config) {
			this.config = config;
		}

		/*
		 * (non-Javadoc)
		 * 
		 * @see org.apache.commons.pool.PoolableObjectFactory#makeObject()
		 */
		public FTPClient makeObject() throws Exception {
			FTPClient ftpClient = new FTPClient();
			ftpClient.setConnectTimeout(config.getClientTimeout());
			try {
				ftpClient.connect(config.getHost(), config.getPort());
				int reply = ftpClient.getReplyCode();
				if (!FTPReply.isPositiveCompletion(reply)) {
					ftpClient.disconnect();
					return null;
				}
				boolean result = ftpClient.login(config.getUsername(), config.getPassword());
				if (!result) {
					throw new FTPClientException("ftpClient login fail! userName:"
							+ config.getUsername() + " ; password:"
							+ config.getPassword());
				}
				ftpClient.setFileType(config.getFileType());
				ftpClient.setBufferSize(1024);
				ftpClient.setControlEncoding(config.getEncoding());
				if (config.getPassiveMode().equals("true")) {
					ftpClient.enterLocalPassiveMode();
				}
			} catch (IOException e) {
				e.printStackTrace();
			} catch (FTPClientException e) {
				e.printStackTrace();
			}
			return ftpClient;
		}

		/*
		 * (non-Javadoc)
		 * 
		 * @see
		 * org.apache.commons.pool.PoolableObjectFactory#destroyObject(java.lang.Object)
		 */
		public void destroyObject(FTPClient ftpClient) throws Exception {
			try {
				if (ftpClient != null && ftpClient.isConnected()) {
					ftpClient.logout();
				}
			} catch (IOException io) {
				io.printStackTrace();
			} finally {
				// 注意,一定要在finally代码中断开连接，否则会导致占用ftp连接情况
				try {
					ftpClient.disconnect();
				} catch (IOException io) {
					io.printStackTrace();
				}
			}
		}

		/*
		 * (non-Javadoc)
		 * 
		 * @see
		 * org.apache.commons.pool.PoolableObjectFactory#validateObject(java.lang.Object)
		 */
		public boolean validateObject(FTPClient ftpClient) {
			try {
				return ftpClient.sendNoOp();
			} catch (IOException e) {
				throw new RuntimeException("Failed to validate client: " + e, e);
			}
		}

		public void activateObject(FTPClient ftpClient) throws Exception {
		}

		public void passivateObject(FTPClient ftpClient) throws Exception {

		}

		@Override
		public void activateObject(Object obj) throws Exception {
			
		}

		@Override
		public void destroyObject(Object obj) throws Exception {
		}

		@Override
		public void passivateObject(Object obj) throws Exception {
		}

		@Override
		public boolean validateObject(Object obj) {
			return false;
		}
	}
	
	/**
	 * FTPClient配置类，封装了FTPClient的相关配置
	 */
	public static class FTPClientConfigure {
		private String host;
		private int port;
		private String username;
		private String password;
		private String passiveMode;
		private String encoding;
		private int clientTimeout;
		private int threadNum;
		private int fileType;
		private boolean renameUploaded;
		private int retryTimes;

		public String getHost() {
			return host;
		}

		public void setHost(String host) {
			this.host = host;
		}

		public int getPort() {
			return port;
		}

		public void setPort(int port) {
			this.port = port;
		}

		public String getUsername() {
			return username;
		}

		public void setUsername(String username) {
			this.username = username;
		}

		public String getPassword() {
			return password;
		}

		public void setPassword(String password) {
			this.password = password;
		}

		public String getPassiveMode() {
			return passiveMode;
		}

		public void setPassiveMode(String passiveMode) {
			this.passiveMode = passiveMode;
		}

		public String getEncoding() {
			return encoding;
		}

		public void setEncoding(String encoding) {
			this.encoding = encoding;
		}

		public int getClientTimeout() {
			return clientTimeout;
		}

		public void setClientTimeout(int clientTimeout) {
			this.clientTimeout = clientTimeout;
		}

		public int getThreadNum() {
			return threadNum;
		}

		public void setThreadNum(int threadNum) {
			this.threadNum = threadNum;
		}

		public int getFileType() {
			return fileType;
		}

		public void setFileType(int fileType) {
			this.fileType = fileType;
		}

		public boolean isRenameUploaded() {
			return renameUploaded;
		}

		public void setRenameUploaded(boolean renameUploaded) {
			this.renameUploaded = renameUploaded;
		}

		public int getRetryTimes() {
			return retryTimes;
		}

		public void setRetryTimes(int retryTimes) {
			this.retryTimes = retryTimes;
		}

		@Override
		public String toString() {
			return "FTPClientConfig [host=" + host + "\n port=" + port
					+ "\n username=" + username + "\n password=" + password
					+ "\n passiveMode=" + passiveMode + "\n encoding="
					+ encoding + "\n clientTimeout=" + clientTimeout
					+ "\n threadNum=" + threadNum + "\n fileType="
					+ fileType + "\n renameUploaded=" + renameUploaded
					+ "\n retryTimes=" + retryTimes + "]";
		}

	}
	
	public static class FTPClientException extends RuntimeException {
		private static final long serialVersionUID = 6639689724672349724L;
		
		public FTPClientException() {
	        super();
	    }

	    public FTPClientException(String message) {
	        super(message);
	    }
	}

	public static void main(String[] args) throws Exception {
		for (int i=0; i<1; i++) {
			FTPClientConfigure config = new FTPClientConfigure();  
	        config.setHost("127.0.0.1");
	        config.setPort(21);
	        config.setUsername("admin");
	        config.setPassword("smalle");
	        config.setFileType(FTPClient.BINARY_FILE_TYPE); // 图片上传是一定要设置
	        config.setPassiveMode("false");
	        config.setClientTimeout(30 * 1000);
	          
	        FtpClientFactory factory = new FtpClientFactory(config);
	        FtpU.pool = new FTPClientPool(factory);
	        ftpClient = pool.borrowObject();
	        
	        // File file = new File("d:/temp/1.png");
	        // FtpU.upload(file);
	        
	        // FtpU.upload(file, "img");
	        // FtpU.upload(StringU.nowTime("yyyyMMddHHmmddSS") + file.getName(), new FileInputStream(file));
		
	        FtpU.download("d:/temp/download/", "/test.txt");
		}
	}
}
